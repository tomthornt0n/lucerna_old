#define LC_MAX_ENTITIES 1000
#define LC_NO_ENTITY 0xffffffffffffffff

#define LC_SUBSET_LOOP(subset)                                                                   \
int i;                                                                                           \
for(i = 0; i < sb_count(subset->Entities); ++i)                                                  \
{                                                                                                \
    lc_Entity entity                                       = subset->Entities[i];                \
    lc_Scene* scene                                        = subset->Parent;

#define LC_END_SUBSET_LOOP }

typedef uint64_t lc_Signature;
typedef uint32_t lc_Entity;

typedef struct
{
    //bit fields to store which components each entity has
    lc_Signature EntitySignatures[LC_MAX_ENTITIES];

    //an array for each component type
    //place the arrays generated by data_desk here
#include "ComponentArrays.gen.c"
    //manually create arrays for built in components
    lc_Renderable LcRenderable[LC_MAX_ENTITIES];
} lc_Scene;

typedef struct
{
    lc_Signature Signature; //the minimum components an entity must have to be added to the scene
    lc_Entity* Entities; //stretchy buffer of all entities which have at least the components specified in the signature
    lc_Scene* Parent; //pointer back to the scene that it is a subset of
} lc_Subset;


/* allocates a new scene and
   returns a pointer to it
*/
lc_Scene* lc_CreateScene(void)
{
    lc_Scene* scene                                        = malloc(sizeof(lc_Scene));

    lc_Entity i;
    for (i = 0; i < LC_MAX_ENTITIES; ++i)
        scene->EntitySignatures[i]                         = LC_NO_ENTITY;

    return scene;
}

/* frees the memory allocated by lc_CreateScene.
   Currently doesn't do anything special,
   but pobably better to use this incase I decide that it should in the future
*/
void lc_DestroyScene(lc_Scene* scene)
{
    free(scene);
}

/* sets up a new subset of the system's entities
   and returns a pointer to it.
   Useful for iterating over only specific entities
*/
lc_Subset* lc_CreateSubset(lc_Scene* scene)
{
    //allocate memory for the sub-set
    lc_Subset* subset                                      = malloc(sizeof(lc_Subset));

    //initialise its fields
    subset->Signature                                      = LC_COMPONENT_NONE;
    subset->Entities                                       = NULL;
    subset->Parent                                         = scene;

    //return the pointer
    return subset;
}

/* Frees the memory allocated by lc_CreateSubset
*/
void lc_DestroySubset(lc_Subset* subset)
{
    sb_free(subset->Entities);
    free(subset);
}

/* Sets the 'signature' of the subset.
   Compared against the signatures of the entities in its parent scene
   when lc_RefreshSubset is called.
*/
void lc_SetSubsetSignature(lc_Subset* subset, lc_Signature components)
{
    subset->Signature                                      = components;
}

/* Compares entity signatures in its parent scene with the subset's signature
   All entities containing at least those specified by the subset will be added
*/
void lc_RefreshSubset(lc_Subset* subset)
{
    sb_free(subset->Entities);
    subset->Entities                                       = NULL;
    int i;
    for (i = 0; i < LC_MAX_ENTITIES; ++i)
    {
        if (((subset->Signature & subset->Parent->EntitySignatures[i]) == subset->Signature) && subset->Parent->EntitySignatures[i] != LC_NO_ENTITY)
            sb_push(subset->Entities, i);
    }
}

/* Finds the first free entity ID in the scene and returns it
*/
lc_Entity lc_CreateEntity(lc_Scene* scene)
{
    lc_Entity entity;
    for (entity = 0; entity < LC_MAX_ENTITIES; entity++)
    {
        if (scene->EntitySignatures[entity] == LC_NO_ENTITY)
        {
            scene->EntitySignatures[entity] = LC_COMPONENT_NONE;
            return entity; //return the first empty entity ID
        }
    }
    //throw an assert if the array is full
    LC_ASSERT(false, "Too many entities in scene!");
    //return an arbitrary value to stop the compiler complaining (will always exit before this point so doesn't matter what)
    return 0;
}

/* remove all components from the entity, so the ID can be allocated again
*/
void lc_DestroyEntity(lc_Scene* scene, lc_Entity entity)
{
    scene->EntitySignatures[entity]                        = LC_COMPONENT_NONE;
}

//place the functions generated by data_desk here
#include "EcsFunctions.gen.c"
