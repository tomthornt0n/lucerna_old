#define MAX_ENTITIES 1000

#define LC_SUBSET_LOOP(subset)                                                                   \
for(int i = 0; i < sb_count(subset->Entities); ++i)                                              \
{                                                                                                \
	lc_Entity entity                                       = subset->Entities[i];                \
	lc_Scene* scene                                        = subset->Parent;

#define LC_END_SUBSET_LOOP }

typedef uint32_t lc_Signature;
typedef uint32_t lc_Entity;

typedef struct
{
	//bit fields to store which components each entity has
	lc_Signature EntitySignatures[MAX_ENTITIES];

	//an array for each component type
	//place the arrays generated by data_desk here
#include "ComponentArrays.gen.c"
} lc_Scene;

typedef struct
{
	lc_Signature Signature; //the minimum components an entity must have to be added to the scene
	lc_Entity* Entities; //stretchy buffer of all entities which have at least the components specified in the signature
	lc_Scene* Parent; //pointer back to the scene that it is a subset of
} lc_Subset;


/* allocates a new scene and
   returns a pointer to it
*/
lc_Scene* lc_CreateScene()
{
	lc_Scene* scene                                        = malloc(sizeof(lc_Scene));

	for (lc_Entity i = 0; i < MAX_ENTITIES; ++i)
		scene->EntitySignatures[i]                         = LC_COMPONENT_NONE;

	return scene;
}

/* frees the memory allocated by lc_CreateScene.
   Currently doesn't do anything special,
   but pobably better to use this incase I decide that it should in the future
*/
void lc_DestroyScene(lc_Scene* scene)
{
	free(scene);
}

/* sets up a new subset of the system's entities
   and returns a pointer to it.
   Useful for iterating over only specific entities
*/
lc_Subset* lc_CreateSubset(lc_Scene* scene)
{
	//allocate memory for the sub-set
	lc_Subset* subset                                      = malloc(sizeof(lc_Subset));

	//initialise its fields
	subset->Signature                                      = LC_COMPONENT_NONE;
	subset->Entities                                       = NULL;
	subset->Parent                                         = scene;

	//return the pointer
	return subset;
}

/* Frees the memory allocated by lc_CreateSubset
*/
void lc_DestroySubset(lc_Subset* subset)
{
	sb_free(subset->Entities);
	free(subset);
}

/* Sets the 'signature' of the subset.
   Compared against the signatures of the entities in its parent scene
   when lc_RefreshSubset is called.
*/
void lc_SetSubsetSignature(lc_Subset* subset, lc_Signature components)
{
	subset->Signature                                      = components;
}

/* Compares entity signatures in its parent scene with the subset's signature
   All entities containing at least those specified by the subset will be added
*/
void lc_RefreshSubset(lc_Subset* subset)
{
	sb_free(subset->Entities);
	subset->Entities                                       = NULL;
	for (int i = 0; i < MAX_ENTITIES; ++i)
	{
		if ((subset->Signature & subset->Parent->EntitySignatures[i]) == subset->Signature)
			sb_push(subset->Entities, i);
	}
}

/* Finds the first free entity ID in the scene and returns it
*/
lc_Entity lc_CreateEntity(lc_Scene* scene)
{
	lc_Entity entity;
	for (entity = 0; entity < MAX_ENTITIES; entity++)
	{
		if (scene->EntitySignatures[entity] == LC_COMPONENT_NONE)
			return entity; //return the first empty entity ID
	}
	//throw an assert if the array is full
	LC_ASSERT(false, "Too many entities in scene!");
	return NULL;
}

/* remove all components from the entity, so the ID can be allocated again
*/
void lc_DestroyEntity(lc_Scene* scene, lc_Entity entity)
{
	scene->EntitySignatures[entity]                        = LC_COMPONENT_NONE;
}

/* Sets an entities signature
   so you can check which components it contains
*/
static void lc_AddComponent(lc_Scene* scene, lc_Entity entity, lc_Signature component)
{
	scene->EntitySignatures[entity]                       |= component;
	return;
}

//place the functions generated by data_desk here
#include "EcsFunctions.gen.c"
